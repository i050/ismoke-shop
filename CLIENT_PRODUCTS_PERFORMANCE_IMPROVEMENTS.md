# תכנית שיפור ביצועים לעמוד "כל המוצרים" בצד הקליינט

## הקשר ומטרות
- להביא את חוויית הסינון והדפדוף למהירה ותגובה, ללא שינוי התנהגות פונקציונלית וללא שבירת UX קיים.
- לצמצם עומסים על השרת והדפדפן באמצעות הורדת כמות הקריאות המיותרות, קיצור זמני חסימה ב-Main Thread והפחתת רינדורים חוזרים.

## טבלת מהלכים (RICE מקוצר)
| עדיפות | רכיב | שיפור מוצע | מאמץ | אימפקט צפוי |
| --- | --- | --- | --- | --- |
| גבוהה | useFilteredProducts.ts | העלאת debounce ל-400-500ms עם ביטול קריאות על input מהיר מאוד | נמוך | ירידה ~35%-45% בכמות הקריאות בעת שינוי כמה פילטרים ברצף |
| גבוהה | useFilteredProducts.ts + ProductService | הוספת cache קצר (per-key ל-120 שניות) + prefetch לעמוד הבא | בינוני | צמצום זמן המתנה לעמוד שחוזרים אליו ב~60% |
| גבוהה | ProductsPage.tsx | Dedup ל-socket events (בדיקת דלתא לפני רענון) | בינוני | מניעת burst קריאות חוזרות תוך כדי אירועי מחיר/מלאי |
| בינונית | useFiltersState.ts | Memoization לתוצאת getAllDescendantIds והתבססות על מבנה map מוכן | בינוני | קיצור חישוב toggle קטגוריות ב~70% בעומק גבוה |
| בינונית | CategoriesTree.tsx | עטיפת צמתים ב-React.memo + key יציב | נמוך | הורדת רינדורים חוזרים של כל העץ בזמן שינוי יחיד |
| בינונית | ProductCard.tsx | מיזוג מאזיני socket למאזין יחיד גריד-רמה והפצת state פנימית | בינוני | הורדת כמות המנויים מ-n cards ל-1, שיפור FPS בגלילה |
| בינונית | ProductGrid.tsx | הטמעת virtualization (לדוגמה react-window) ברשימות ארוכות | בינוני | שיפור ביצועי גלילה בעמודים עם >40 פריטים |
| נמוכה | buildQuery.ts | שמירת query string אחרון כדי למנוע stringify כפולים | נמוך | רווח קטן ב-Main Thread אך כמעט חינם |

## פירוט שיפורים

### 1. שכבת הרשת וה-fetch
- **Debounce ארוך יותר**: המעבר ל-400-500ms ברכיב `useFilteredProducts.ts` יאפשר למשתמש לסיים צירוף של כמה תנאי סינון לפני יציאה לפetch. יש לוודא שקריאה מוקדמת במהלך blur של שדה תישלח מידית (onCommit) כדי לא לפגוע בתחושת השליטה.
- **Cache קצר טווח**: החזקת Map לפי חתימת query (JSON יציב) עם TTL של כ-120 שניות. שימוש ב-AbortController יישאר לזיהוי race, אך קומבינציה עם cache תמנע spinner בעת חזרה לאותו עמוד.
- **Invalidate ברור**: לכל רשומת cache לצרף timestamp ולוגיקת bust אוטומטית (TTL) וגם invalidate ידני בעת שינוי פילטרים דרמטיים (למשל מעבר בין טאב מוצרים). כך נמנע מצב של נתונים מיושנים.
- **שמירה על AbortController**: להבטיח שכל fetch חדש מבטל מיידית את הקודם (כולל פעולות prefetch) כדי שלא תהיה הצפה של קריאות רקע בזמן שהמשתמש משנה קלט במהירות.
- **Prefetch לעמוד הבא**: לאחר קבלת מטא-נתונים (מספר עמודים), אם page < totalPages יש לטריגר פetch שקט לעמוד הבא. זה מזרז גלילה קדימה בלי לחכות לסוף.
- **טיפול ב-socket events**: לפני קריאת רענון, יש לבדוק אם האירוע משפיע על הפילטרים הנוכחיים (לפי productId/category). אירועים שנוגעים לאובייקטים שלא מוצגים לא יפעילו fetch. מומלץ להשתמש ב-scheduler תור של 1 לכל 1-2 שניות (throttle) כדי לאחד פולים.

### 2. ניהול state ופילטרים
- **Memoization לעץ קטגוריות**: לבנות map של parent->descendants בזמן הטעינה (`categoriesSlice`), לשמור אותו ב-selectors ולהשתמש בו ב-`useFiltersState`. כך הפעלה של toggle תהיה O(1) במקום O(n) על כל העץ.
- **הפרדת state selection**: ב-`useFilteredProducts` ניתן לפרק את ה-selector ל-parts ולהשתמש ב-`shallow` מ-`useSelector` / `useAppSelector` כדי למנוע רינדור מלא כאשר meta לא השתנתה.
- **שמירת query אחרון**: ב-`buildQuery.ts` לשמור reference של query string שנבנה מהפילטרים האחרונים ולהשוות אובייקטים (deep compare זול באמצעות `fast-deep-equal`).

### 3. רינדור ו-UI
- **React.memo בצמתים**: לעטוף כל צומת בקטגוריות (`CategoryTreeNode`) ב-React.memo עם props נייטרליים (checked, expanded, label). שימוש ב-selector מבוסס id ימנע רינדורים של צמתים שלא הושפעו.
- **Virtualized Grid**: ב-`ProductGrid.tsx` אפשר לעבור ל-react-window (גודל ריבועים קבוע) או react-virtuoso (גודל דינמי). מינימום 40 פריטים בעמוד מצדיק זאת. יש להוסיף placeholder skeleton קצר לכניסה ראשונה.
- **Skeleton ו-loading states**: להוסיף שכבת skeleton/placeholder עקבית בעת טעינה מחדש או בזמן פיצול גריד (כולל במעבר בין עמודים). חשוב לשמור על פרופורציות הגובה כדי למנוע קפיצות layout.
- **Socket יחיד לכרטיסים**: ליצור hook חדש `useProductsSocket` שמאזין פעם אחת (ברמת ProductsPage) ומעדכן context. הכרטיסים יצרכו context ולא יחזיקו חיבור עצמאי.
- **הפחתת console.logs**: להסיר או לשים מאחורי דגל DEBUG כדי למנוע חסימת Main Thread.

### 4. ניטור ואימות
- **מדדי ביצועים**: להוסיף מדידה עם `performance.mark` לפני/אחרי fetch ו/או להשתמש ב-`web-vitals` לדגימת CLS/INP. ריכוז הנתונים ב-logrocket/segment להשוואה לפני/אחרי.
- **בדיקות רגרסיה**: להריץ Cypress עם תרחיש סינון אינטנסיבי ולמדוד ספייקים. לשמור צילום Lighthouse לפני ואחרי.

## תכנית Rollout
1. **שלב 1** – שיפורי debounce + socket dedup + הורדת console logs. בדיקה: מדידת כמות קריאות fetch בפרופילר.
2. **שלב 2** – Cache + memoization של העץ. בדיקה: פרופיל Performance בגלילת קטגוריות עמוקה.
3. **שלב 3** – Virtualization ו-prefetch לעמוד הבא. בדיקה: Lighthouse ו-React Profiler במדידת renders.
4. **שלב 4** – ניטור מתמשך והפעלת flags (אפשר לעטוף ב-feature flags להדלקה הדרגתית).

## הערכות הצלחה
- ירידה של לפחות 40% בכמות בקשות fetch במהלך סשן פילטרים סטנדרטי.
- שיפור INP מתחת ל-200ms ברוב מכשירי דסקטופ.
- הורדת זמן תגובה של פתיחת/סגירת קטגוריות ל<16ms.
- שמירה על עקביות UX קיימת (אין שינוי בסדר פעולות המשתמש).

## תלויות
- יש לוודא שהשרת תומך במטמון קצר (או לכל הפחות שלא החזרת נתונים ישנים תיצור חוסר עקביות). אפשר להוסיף header `X-Cacheable: 120` כדי לאפשר בקרה.
- Virtualization דורש שהגובה של כרטיס יהיה ידוע. במידה ויש גובה דינמי צריך להשתמש ב-react-virtuoso עם מדידות.
- Prefetch דורש שה-API מחזיר מטא מדויק (totalPages / totalCount). אם אין, יש להוסיף תחילה בצד השרת.
- מומלץ לתאם עם צוות ה-Backend על הוספת אינדקסים לקטגוריות/תגים פופולריים כדי שהשיפורים בצד הקליינט לא יתקלו בבקשות איטיות מהשרת.

## מעקב אחרי יישום
- לפתוח משימות Jira לכל סעיף עם Acceptance Criteria מדיד.
- להוסיף בדיקת PR שמביאה מדידת fetch count מלפני ואחרי (אפשר להשתמש ב-Playwright).
- בכל שלב למדוד ולתעד ב-`performance-log.md` כדי לשמר ידע.
